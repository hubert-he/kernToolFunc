#include <stdio.h>#include <string.h>typedef unsigned int uint32;typedef unsigned char uint8;char hex_asc[] = "0123456789abcdef";char hex_asc_u[] = "0123456789ABCDEF";static char line[80];#define hex_asc_lo(x)	hex_asc[((x) & 0x0f)]#define hex_asc_hi(x)	hex_asc[((x) & 0xf0) >> 4]static inline char *pack_hex_byte(char *buf, uint8 byte){	*buf++ = hex_asc_hi(byte);	*buf++ = hex_asc_lo(byte);	return buf;}typedef char *	va_list;#define _INTSIZEOF(n)	( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )#define va_start(ap,v)	( ap = (va_list)&v + _INTSIZEOF(v) )#define va_arg(ap,t)	(  (sizeof(t) == sizeof(double)) ? \                                                      ((ap = (char *)(((int)ap + 7) & ~7)), (ap += 8), (*(t *)(ap - 8))) \                                                    : (*(t*)((ap += _INTSIZEOF(t)), (ap - _INTSIZEOF(t))))  )#define va_end(ap)	( ap = (va_list)0 )typedef struct printf_arguments  {  unsigned int *args;  unsigned  int *arg1;  unsigned  int *arg2;  unsigned  int *arg3;  unsigned  int *arg4;  unsigned  int *arg5;  unsigned  int *arg6;  unsigned  int *arg7;  unsigned  int *arg8;  unsigned  int *arg9;  unsigned  int *arg10;  unsigned  int *arg11;  unsigned  int *arg12;  unsigned  int *arg13;  unsigned  int *arg14;  unsigned  int *arg15;  unsigned  int *arg16;  } PRTARGS;typedef struct{   unsigned int   *next;     uint8  buffer[2048];} PBUFFER;typedef struct{    PBUFFER *pbufferp;    uint8   *bufferp;    int      counter;} PDESC;typedef struct{    const char   *fmt;       /* will point to the format argument of printf */    uint8  buf[30];   /* storage for building number strings */    uint8 *prtbuf;    /* will point to the next available slot in buffer */} XDOPRNT_DATA;static int xconv(XDOPRNT_DATA *datap, uint32 **argpp){	uint8 c;	int n;	for ( n= 0; (c = *datap->fmt); datap->fmt++)	{		if (c < '0' || c > '9')  break;		n = n * 10 + c - '0';	}		if (n == 0 && *datap->fmt == '*')	{		datap->fmt++;		return (*(*argpp)++);	}	return (n);}static xprnum(datap, n, radix)XDOPRNT_DATA *datap;int n;int radix;{if (n == 0) return;xprnum(datap, n / radix, radix);n = n % radix;*datap->prtbuf++ = hex_asc_u[(int) n];}static xprlox(datap,n,nb,w)XDOPRNT_DATA *datap;int n;int nb,w;{if ((n == 0) || (nb < 1)) return;xprlox(datap, n >> w, nb - w, w);*datap->prtbuf++ = hex_asc_u[n & ((1 << ((nb > w) ? w : nb)) - 1)];}static void xprdata(XDOPRNT_DATA *datap, uint32 *first_arg, uint32 **argv, int ll, int sign, unsigned radix, int upper){	uint32 *args = *argv;	long long n;	if (ll)	{		if (!((uint32)(args - first_arg) & 1))		{			args++;		}				*(unsigned long *)(&n) = *args;		*((unsigned long *)(&n) + 1) = *(args + 1);		args += 2;	}	else	{		n = sign ? (long long)*(int *)args : *args;		args++;	}		if (0 == n)	{		*datap->prtbuf++ = '0';	}	else	{		if (sign && n < 0) 		{			*datap->prtbuf++ = '-';			n = -n;		}		switch (radix)		{			case 8:				xprlox(datap, (unsigned long long)n, 64, 3, upper);				break;			case 16:				xprlox(datap, (unsigned long long)n, 64, 4, upper);				break;			default:				xprnum(datap, (unsigned long long)n, radix, upper);				break;		}	}	*argv = args;}static int xdoprnt(int (*rtn)(uint8, PDESC*), char **arg, const char *f, uint32 **argv){	XDOPRNT_DATA data;     /* doprint data structure */	uint32 *args;          /* argument */	uint8 c;	uint8 *s;	int rjust;           /* right justify */	uint8 padchar;	int width, prec;	int len, m, prec_set;	int retval = 0;	int ll;	uint32 *first_arg = (uint32 *)argv;		data.prtbuf = data.buf;     /* get data buffer pointer */	data.fmt = f;               /* save format */	while ((c = *data.fmt++))	{		if (c != '%')		{			(*rtn)(c, (PDESC*)arg);retval++;   			continue;		}		if (*data.fmt == '-') 		{			rjust=0;			data.fmt++;		}/* use left justification */		else		{			rjust = 1;		}		padchar = (*data.fmt == '0') ? '0' : ' ';		width = xconv(&data, argv);   /* get width of printf's argument*/		if (*data.fmt == '.')		{			data.fmt++;			prec = xconv(&data, argv);			prec_set = 1;		}		else		{			prec = 6;			prec_set = 0;		}		s = 0;		args = (uint32 *)argv;		ll = 0;		switch (c = *data.fmt++)		{			case 'l':				if ('l' == *data.fmt)				{					ll = 1;					data.fmt++;				}				break;			case 'h': /* half word */ /* for mips, parameter type with short/char are promoted to int */				if ('h' == *data.fmt) /* byte */				{					data.fmt++;				}				break;							case 'L':			case 'q':				ll = 1;				break;			default:				data.fmt--;				break;		}				switch (c = *data.fmt++)		{			case 'd':			case 'D':				prec = 0;				xprdata(&data, first_arg, &args, ll, 1, 10, c == 'D');				break;			case 'i':			case 'I':				prec = 0;				xprdata(&data, first_arg, &args, ll, 1, 10, c == 'I');				break;			case 'u':			case 'U':				prec = 0;				xprdata(&data, first_arg, &args, ll, 0, 10, c == 'U');				break;							case 'O':			case 'X':			case 'P':				prec = 0;				xprdata(&data, first_arg, &args, ll, 0, c == 'O' ? 8 : 16, 1);				break;			case 'o':			case 'x':			case 'p':				prec = 0;				xprdata(&data, first_arg, &args, ll, 0, c == 'o' ? 8 : 16, 0);				break;								case 's':				if (!prec_set) prec = 0;				s = (uint8 *) (*argv);				*args++;				break;			case 'c':				*data.prtbuf++ = (uint8) *args++;				break;			case 'r':			default:				(*rtn)(c, (PDESC*)arg); retval++;				break;		}   /* end of while loop */		if (s == 0) { *data.prtbuf = '\0';  s = data.buf;  }		len = strlen((const char *)s);		len = (prec < len && prec > 0 && s != data.buf) ? prec : len;		m = width - len;		if (rjust) 		while (m-- > 0) {			(*rtn)(padchar, (PDESC*)arg);retval++;		}		while (len--) {			(*rtn)(*s++, (PDESC*)arg);retval++;		}		while (m-- > 0) {			(*rtn)(padchar, (PDESC*)arg);retval++;		}		data.prtbuf = data.buf;		argv = (uint32 **)args;	}  /* end of while oop */QUIT:	return retval;}static int xsprintf_nchar(uint8 character,PDESC  *pdescp){	if (pdescp->counter == 0)		return 0;	*pdescp->bufferp++ = character;	pdescp->counter--;	return (1);}int xvsnprintf(char *buf, unsigned int size, const char *fmt, va_list va) {	PRTARGS args0;	PRTARGS *args;	PDESC pdesc;	int ret;	   	args0.args = (unsigned int *)va_arg(va, unsigned int);	args0.arg1 = (unsigned int *)va_arg(va, unsigned int); 	args0.arg2 = (unsigned int *)va_arg(va, unsigned int); 	args0.arg3 = (unsigned int *)va_arg(va, unsigned int); 	args0.arg4 = (unsigned int *)va_arg(va, unsigned int);	args0.arg5 = (unsigned int *)va_arg(va, unsigned int); 	args0.arg6 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg7 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg8 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg9 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg10 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg11 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg12 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg13 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg14 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg15 = (unsigned int *)va_arg(va, unsigned int);    	args0.arg16 = (unsigned int *)va_arg(va, unsigned int);	pdesc.pbufferp = 0;	pdesc.bufferp = buf;	pdesc.counter = size;// xdoprnt(int (*rtn)(uint8, PDESC*), char **arg, char *f, uint32 **argv)   	ret = xdoprnt( xsprintf_nchar, (char **)&pdesc, fmt, (uint32 **)&args0);   	if (pdesc.counter) //still have space.   		*pdesc.bufferp = '\0';   	else   		buf[size-1] = '\0';    	return(ret);}int xsprintf(char *buffer, char *fmt, ...){   va_list va;	int ret;	va_start(va, fmt);	ret = xvsnprintf(buffer, 0xffffffff, fmt, va);	va_end(va);	return ret;}char* fmtline(void *fp, char * addr,char *buf,unsigned short len){	register char *aptr,*cptr;	register char c;	memset(line,' ',sizeof(line));	line[0]=0;	xsprintf(line, "0x%08x:", buf);	line[11]=' ';	aptr = &line[12];	cptr = &line[60];	while(len-- != 0)	{		c = *buf++;		pack_hex_byte(aptr,(uint8)(c));		aptr += 3;		if (( c>= 0x20) && ( c < 0x7f)) *cptr++ = c;		else *cptr++ = '.';	}	*cptr++ = '\n';	*cptr++ = 0;	printk(KERN_WARNING "%s", line);	return(line);}char *dumpBuffer( void *fp, char *datap, int len){	int index, length;	char *xline;	xline=0;	length = len;	for ( index=0; index < length ; index+=16)	{		if ( (length-index) >=16)			xline=fmtline( fp, datap+index, datap+index, 16);		else			xline=fmtline( fp, datap+index, datap+index, (length-index));	}	return(xline);}int main(){	char *ss = "hello world";	dumpBuffer(0, ss, strlen(ss));	return 0;}