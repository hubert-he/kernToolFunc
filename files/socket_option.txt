http://man7.org/linux/man-pages/man7/socket.7.html
https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/7/html/Performance_Tuning_Guide/sect-Red_Hat_Enterprise_Linux-Performance_Tuning_Guide-Networking-Configuration_tools.html
1. SO_BINDTODEVICE: 
	sk->sk_bound_dev_if 对应的是struct net_device中的ifindex
	setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, "eth0", sizeof("eth0"))
2. SO_DEBUG
	sk->sk_flags |= SOCK_DBG
	int val;
	setsockopt(fd, SOL_SOCKET, SO_DEBUG, &val, sizeof(int))
3. SO_REUSEADDR
	sk->sk_reuse
4. SO_TYPE
	只能getsockopt 
5. SO_ERROR
	Get and clear the pending socket error.
	只能getsockopt 
6. SO_DONTROUTE
	Don't send via a gateway, send only to directly connected hosts.
	sk->sk_flags |= SOCK_LOCALROUTE
7. SO_BROADCAST
	sk->sk_flags |= SOCK_BROADCAST
8. SO_SNDBUF
	int
	sk->sk_sndbuf
	sk->sk_write_space: 唤醒进程通知有更多的send缓冲区
	SOCK_MIN_SNDBUF < sk->sk_sndbuf <　sysctl_wmem_max
9. SO_SNDBUFFORCE [since Linux 2.6.14]
	int
	CAP_NET_ADMIN
	sk->sk_sndbuf
	sk->sk_write_space: 唤醒进程通知有更多的send缓冲区
	SOCK_MIN_SNDBUF < sk->sk_sndbuf : 无上限值
10. SO_RCVBUF
	int
	sk->sk_rcvbuf
	SOCK_MIN_RCVBUF <　sk->sk_rcvbuf <　sysctl_rmem_max
11. SO_RCVBUFFORCE
	CAP_NET_ADMIN
	int
	sk->sk_rcvbuf
	SOCK_MIN_RCVBUF <　sk->sk_rcvbuf : 无上限值
12. SO_KEEPALIVE
	bool int
	sk->sk_flags |= SOCK_KEEPOPEN
	TCP: sk->sk_timer  tp->keepalive_time[sysctl_tcp_keepalive_time]
13. SO_OOBINLINE
	bool int
	sk->sk_flags |= SOCK_URGINLINE
	If this option is enabled, out-of-band data is directly placed
    into the receive data stream.  Otherwise, out-of-band data is
    passed only when the MSG_OOB flag is set during receiving.
14. SO_NO_CHECK
	bool int
	sk->sk_no_check
15. SO_PRIORITY
	int
	sk->sk_priority
	Set the protocol-defined priority for all packets to be sent
    on this socket.  Linux uses this value to order the networking
    queues: packets with a higher priority may be processed first
    depending on the selected device queueing discipline.  Setting
    a priority outside the range 0 to 6 requires the CAP_NET_ADMIN
    capability.
16. SO_LINGER
	struct linger{ int l_onoff;    /* linger active */ 
                   int l_linger;   /* how many seconds to linger for */
                 };
	sk->sk_flags |= SOCK_LINGER
	sk->sk_lingertime < MAX_SCHEDULE_TIMEOUT
17. SO_BSDCOMPAT
	废弃，使用此选项，kernel打印warnning信息
18. SO_PASSCRED
	bool int
	sk->sk_flags |= SOCK_PASSCRED
	未知
19. SO_TIMESTAMP
	bool int 
	sk->sk_flags |= !SOCK_RCVTSTAMPNS
	sk->sk_flags |= SOCK_RCVTSTAMP
	sk->sk_flags |= SOCK_TIMESTAMP
20. SO_TIMESTAMPNS
	bool int 
	sk->sk_flags |= SOCK_RCVTSTAMPNS
	sk->sk_flags |= SOCK_RCVTSTAMP
	sk->sk_flags |= SOCK_TIMESTAMP
21. SO_TIMESTAMPING
22. SO_RCVLOWAT / SO_SNDLOWAT
	int
	sk->sk_rcvlowat
23. SO_RCVTIMEO
	struct timeval
	sk->sk_rcvtimeo
24. SO_SNDTIMEO
	struct timeval
	sk->sk_sndtimeo
25. SO_ATTACH_FILTER
26. SO_DETACH_FILTER
	suggest libpcap
27. SO_PASSSEC
	bool int
	sock->flags |= SOCK_PASSSEC
	未知
28. SO_MARK [since Linux 2.6.25]
	CAP_NET_ADMIN
	int
	sk->sk_mark
	Set the mark for each packet sent through this socket (similar
    to the netfilter MARK target but socket-based).  Changing the
    mark can be used for mark-based routing without netfilter or
    for packet filtering.
29. SO_PEERCRED
	struct ucred
	sk->sk_peercred
	ONLY Getsock
	读取peer的权限
30. SO_PEERNAME
	char *
	sock->ops->getname()
	Only Getsock[Read Only]
31. SO_ACCEPTCONN
	int
	Only Getsock[Read Only]
	Returns a value indicating whether or not this socket has been
		marked to accept connections with listen(2).  The value 0
        indicates that this is not a listening socket, the value 1
        indicates that this is a listening socket.  
32. SO_PROTOCOL[since Linux 2.6.32]
	int
	Read Only
33. SO_PEEK_OFF [since Linux 3.4]
	int
	MSG_PEEK 相关
	The following example serves to illustrate the use of
        SO_PEEK_OFF.  Suppose a stream socket has the following queued
        input data:
            aabbccddeeff
        The following sequence of recv(2) calls would have the effect
        noted in the comments:
        int ov = 4;                  // Set peek offset to 4
        setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));
        recv(fd, buf, 2, MSG_PEEK);  // Peeks "cc"; offset set to 6
        recv(fd, buf, 2, MSG_PEEK);  // Peeks "dd"; offset set to 8
        recv(fd, buf, 2, 0);         // Reads "aa"; offset set to 6
        recv(fd, buf, 2, MSG_PEEK);  // Peeks "ee"; offset set to 8

34. SO_REUSEPORT[since Linux 3.9]
	int
	Permits multiple AF_INET or AF_INET6 sockets to be bound to an
		identical socket address.  This option must be set on each
        socket (including the first socket) prior to calling bind(2)
        on the socket.  To prevent port hijacking, all of the
        processes binding to the same address must have the same
        effective UID.  This option can be employed with both TCP and
        UDP sockets.
    For TCP sockets, this option allows accept(2) load
              distribution in a multi-threaded server to be improved by
              using a distinct listener socket for each thread.  This
              provides improved load distribution as compared to traditional
              techniques such using a single accept(2)ing thread that
              distributes connections, or having multiple threads that
              compete to accept(2) from the same socket.

              For UDP sockets, the use of this option can provide better
              distribution of incoming datagrams to multiple processes (or
              threads) as compared to the traditional technique of having
              multiple processes compete to receive datagrams on the same
              socket.
35. SO_RXQ_OVFL [since Linux 2.6.33]
	Indicates that an unsigned 32-bit value ancillary message
              (cmsg) should be attached to received skbs indicating the
              number of packets dropped by the socket between the last
              received packet and this received packet.

36. SO_BUSY_POLL [since Linux 3.11]
	Sets the approximate time in microseconds to busy poll on a
              blocking receive when there is no data.  Increasing this value
              requires CAP_NET_ADMIN.  The default for this option is
              controlled by the /proc/sys/net/core/busy_read file.

              The value in the /proc/sys/net/core/busy_poll file determines
              how long select(2) and poll(2) will busy poll when they
              operate on sockets with SO_BUSY_POLL set and no events to
              report are found.

              In both cases, busy polling will only be done when the socket
              last received data from a network device that supports this
              option.

              While busy polling may improve latency of some applications,
              care must be taken when using it since this will increase both
              CPU utilization and power usage.
繁忙轮询有助于减少网络接收路径中的延迟， 使 socket 层代码查询网络设备的接收队列并禁用网络中断，这可以消除由于中断和由此产生的环境切换所造成的延误。但是，它会增加 CPU 的使用率。繁忙轮询可以防止 CPU 进入睡眠状态，睡眠状态会造成额外的功耗。
繁忙轮询是默认禁用的。要在特定 socket 中启用繁忙轮询，请按以下指示：
将 sysctl.net.core.busy_poll 设置为除 0 以外的值。这一参数控制的是 socket 轮询和选择位于等待设备队列中数据包的微秒数。红帽推荐值为 50。
添加 SO_BUSY_POLL socket 选项至 socket。
要全局启用繁忙轮询， 须将 sysctl.net.core.busy_read 设置为除了 0 以外的值。这一参数控制了socket 读取位于等待设备队列中数据包的微秒数，且设置了 SO_BUSY_POLL 选项的默认值。红帽推荐在 socket 数量少时将值设置为 50 ， socket 数量多时将值设置为 100。对于 socket 数量极大时（超过几百），请使用 epoll。
繁忙轮询由以下驱动程序支持。红帽企业版 Linux 7 支持这些驱动程序。
bnx2x
be2net
ixgbe
mlx4
myri10ge

===
/proc interfaces
       The core socket networking parameters can be accessed via files in
       the directory /proc/sys/net/core/.

       rmem_default
              contains the default setting in bytes of the socket receive
              buffer.

       rmem_max
              contains the maximum socket receive buffer size in bytes which
              a user may set by using the SO_RCVBUF socket option.

       wmem_default
              contains the default setting in bytes of the socket send
              buffer.

       wmem_max
              contains the maximum socket send buffer size in bytes which a
              user may set by using the SO_SNDBUF socket option.

       message_cost and message_burst
              configure the token bucket filter used to load limit warning
              messages caused by external network events.

       netdev_max_backlog
              Maximum number of packets in the global input queue.

       optmem_max
              Maximum length of ancillary data and user control data like
              the iovecs per socket.



			  ----
int getsockopt(int sock, int level, int optname, void *optval, socklen_t *optlen);
int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen);
参数：  
sock：将要被设置或者获取选项的套接字。
level：选项所在的协议层。
optname：需要访问的选项名。
optval：对于getsockopt()，指向返回选项值的缓冲。对于setsockopt()，指向包含新选项值的缓冲。
optlen：对于getsockopt()，作为入口参数时，选项值的最大长度。作为出口参数时，选项值的实际长度。对于setsockopt()，现选项的长度。

返回说明：  

成功执行时，返回0。失败返回-1，errno被设为以下的某个值  
EBADF：sock不是有效的文件描述词
EFAULT：optval指向的内存并非有效的进程空间
EINVAL：在调用setsockopt()时，optlen无效
ENOPROTOOPT：指定的协议层不能识别选项
ENOTSOCK：sock描述的不是套接字

参数详细说明：
level指定控制套接字的层次.可以取三种值:
1)SOL_SOCKET:通用套接字选项.
2)IPPROTO_IP:IP选项.
3)IPPROTO_TCP:TCP选项.　
optname指定控制的方式(选项的名称),我们下面详细解释　
optval获得或者是设置套接字选项.根据选项名称的数据类型进行转换　			  